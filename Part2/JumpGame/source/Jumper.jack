// Represents the user-controlled jumper in the game.

class Jumper {
  field int x_, y_; // screen location of the jumper's top left corner.

  // the height of the jumper (number of rows), this is also the length of
  // the row-wise bitmap Array.
  field int height_;

  field Array bitmap_vals_; // the row-wise bitmap values of the jumper.

  constructor Jumper new(int x, int y, int height, Array bitmap_vals) {
    let x_ = x;
    let y_ = y;
    let height_ = height;
    let bitmap_vals_ = bitmap_vals;
    return this;
  }

  method void dispose() {
    do bitmap_vals_.dispose();
    do Memory.deAlloc(this);
    return;
  }

  method void draw() {
    do Utils.drawBitMapArray(x_, y_, height_, bitmap_vals_);
    return;
  }

  method void erase() {
    do Utils.eraseBitMap(x_, y_, height_);
    return;
  }

  method void shiftDown(int num_rows) {
    let y_ = y_ + num_rows;
    return;
  }

  method void shiftUp(int num_rows) {
    let y_ = y_ - num_rows;
    return;
  }

  method void shiftRight(int num_cols) {
    let x_ = x_ + num_cols;
    return;
  }

  method void shiftLeft(int num_cols) {
    let x_ = x_ - num_cols;
    return;
  }

  method bool onPlatformAfterLeftStep() {
    var int offset, x, y;
    let x = x_ - Constants.blockSize();
    let y = y_ + height_;

    if ((x < 0) | (y > (Constants.boardHeight() - 1))) {
      return false;
    }

    let offset = Utils.getOffset(x_ - Constants.blockSize(), y_ + height_);
    return (Memory.peek(offset) = -1);
  }

  method bool onPlatformAfterRightStep() {
    var int offset, x, y;
    let x = x_ + Constants.blockSize();
    let y = y_ + height_;

    if ((x > (Constants.boardWidth() - 1)) |
        (y > (Constants.boardHeight() - 1))) {
      return false;
    }

    let offset = Utils.getOffset(x_ + Constants.blockSize(), y_ + height_);
    return (Memory.peek(offset) = -1);
  }

  method int gapBelowObject() {
    var int offset, curr_row, search_row, board_end;
    let board_end = Constants.boardHeight() - 1;
    let curr_row = y_ - 1;
    let search_row = 0;
    let offset = Utils.getOffset(x_, curr_row);

    if (y_ < height_) {
      return y_;
    }

    while (search_row < height_) {
      if (~(curr_row < 0)) {
        if (~(Memory.peek(offset) = 0)) {
          return search_row;
        }
      }
      let offset = offset - Constants.blocksPerRow();
      let search_row = search_row + 1;
      let curr_row = curr_row - 1;
    }
    return search_row;
  }

  method int gapFromObjectOnLeft() {
    var int offset, curr_row, search_row, board_end;
    let board_end = Constants.boardHeight() - 1;
    let curr_row = y_;
    let search_row = 0;
    let offset = Utils.getOffset(x_ - Constants.blockSize(), curr_row);

    if (x_ < Constants.blockSize()) {
      return 0;
    }

    while (search_row < height_) {
      if (~(curr_row > board_end)) {
        if (~(Memory.peek(offset) = 0)) {
          return 0;
        }
      }
      let offset = offset + Constants.blocksPerRow();
      let search_row = search_row + 1;
      let curr_row = curr_row + 1;
    }

    return search_row;
  }

  method int gapFromObjectOnRight() {
    var int offset, curr_row, search_row, board_end, x;
    let board_end = Constants.boardHeight() - 1;
    let curr_row = y_;
    let search_row = 0;
    let x = x_ + Constants.blockSize();
    let offset = Utils.getOffset(x, curr_row);

    if ((x + Constants.blockSize()) > Constants.boardWidth()) {
      return 0;
    }

    while (search_row < height_) {
      if (~(curr_row > board_end)) {
        if (~(Memory.peek(offset) = 0)) {
          return 0;
        }
      }
      let offset = offset + Constants.blocksPerRow();
      let search_row = search_row + 1;
      let curr_row = curr_row + 1;
    }

    return search_row;
  }

  method int gapAbovePlatform() {
    var int offset, curr_row, search_row, board_end;
    let board_end = Constants.boardHeight() - 1;
    let curr_row = y_ + height_ + 1;
    let search_row = 0;
    let offset = Utils.getOffset(x_, curr_row);
    while (search_row < height_) {
      if (~(curr_row > board_end)) {
        if (Memory.peek(offset) = -1) {
          return search_row;
        }
      }
      let offset = offset + Constants.blocksPerRow();
      let search_row = search_row + 1;
      let curr_row = curr_row + 1;
    }
    return search_row;
  }

  method bool isBelowBoard() {
    return Utils.isBelowBoard(y_);
  }
}
